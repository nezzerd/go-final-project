
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>booking-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">hotel-booking-system/cmd/booking-service/main.go (0.0%)</option>
				
				<option value="file1">hotel-booking-system/cmd/delivery-service/main.go (0.0%)</option>
				
				<option value="file2">hotel-booking-system/cmd/hotel-service/main.go (0.0%)</option>
				
				<option value="file3">hotel-booking-system/cmd/notification-service/main.go (0.0%)</option>
				
				<option value="file4">hotel-booking-system/cmd/payment-service/main.go (0.0%)</option>
				
				<option value="file5">hotel-booking-system/cmd/seed/hotel/main.go (0.0%)</option>
				
				<option value="file6">hotel-booking-system/internal/booking/delivery/http/handler.go (51.4%)</option>
				
				<option value="file7">hotel-booking-system/internal/booking/delivery/http/routes.go (100.0%)</option>
				
				<option value="file8">hotel-booking-system/internal/booking/repository/postgres_booking.go (97.4%)</option>
				
				<option value="file9">hotel-booking-system/internal/booking/usecase/booking_usecase.go (79.4%)</option>
				
				<option value="file10">hotel-booking-system/internal/booking/usecase/payment_adapter.go (100.0%)</option>
				
				<option value="file11">hotel-booking-system/internal/delivery/http/handler.go (100.0%)</option>
				
				<option value="file12">hotel-booking-system/internal/delivery/http/routes.go (0.0%)</option>
				
				<option value="file13">hotel-booking-system/internal/delivery/service/notifier.go (65.7%)</option>
				
				<option value="file14">hotel-booking-system/internal/hotel/delivery/http/handler.go (95.8%)</option>
				
				<option value="file15">hotel-booking-system/internal/hotel/delivery/http/routes.go (100.0%)</option>
				
				<option value="file16">hotel-booking-system/internal/hotel/repository/postgres_hotel.go (97.4%)</option>
				
				<option value="file17">hotel-booking-system/internal/hotel/repository/postgres_room.go (100.0%)</option>
				
				<option value="file18">hotel-booking-system/internal/hotel/usecase/hotel_usecase.go (88.6%)</option>
				
				<option value="file19">hotel-booking-system/internal/notification/service/notification_service.go (100.0%)</option>
				
				<option value="file20">hotel-booking-system/internal/payment/delivery/http/handler.go (100.0%)</option>
				
				<option value="file21">hotel-booking-system/internal/payment/delivery/http/routes.go (0.0%)</option>
				
				<option value="file22">hotel-booking-system/internal/payment/service/payment.go (89.3%)</option>
				
				<option value="file23">hotel-booking-system/pkg/database/postgres.go (71.4%)</option>
				
				<option value="file24">hotel-booking-system/pkg/hotelclient/hotel_client.go (54.5%)</option>
				
				<option value="file25">hotel-booking-system/pkg/httpclient/delivery_client.go (88.2%)</option>
				
				<option value="file26">hotel-booking-system/pkg/httpclient/hotel_client.go (93.8%)</option>
				
				<option value="file27">hotel-booking-system/pkg/httpclient/payment_client.go (90.0%)</option>
				
				<option value="file28">hotel-booking-system/pkg/kafka/consumer.go (16.7%)</option>
				
				<option value="file29">hotel-booking-system/pkg/kafka/producer.go (33.3%)</option>
				
				<option value="file30">hotel-booking-system/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file31">hotel-booking-system/pkg/tracing/tracing.go (88.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        httpHandler "hotel-booking-system/internal/booking/delivery/http"
        "hotel-booking-system/internal/booking/repository"
        "hotel-booking-system/internal/booking/usecase"
        "hotel-booking-system/pkg/database"
        "hotel-booking-system/pkg/hotelclient"
        "hotel-booking-system/pkg/httpclient"
        "hotel-booking-system/pkg/kafka"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/tracing"

        "github.com/joho/godotenv"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()

        logger.Init(os.Getenv("LOG_LEVEL"))
        log := logger.GetLogger()

        tp, err := tracing.InitTracer("booking-service", os.Getenv("JAEGER_ENDPOINT"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to init tracer")
        }</span>
        <span class="cov0" title="0">defer tracing.Shutdown(context.Background(), tp)

        dbCfg := database.Config{
                Host:     os.Getenv("BOOKING_DB_HOST"),
                Port:     os.Getenv("BOOKING_DB_PORT"),
                User:     os.Getenv("BOOKING_DB_USER"),
                Password: os.Getenv("BOOKING_DB_PASSWORD"),
                DBName:   os.Getenv("BOOKING_DB_NAME"),
        }

        db, err := database.NewPostgresConnection(dbCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to connect to database")
        }</span>
        <span class="cov0" title="0">defer db.Close()

        bookingRepo := repository.NewPostgresBookingRepository(db)

        hotelClient, err := hotelclient.NewHotelClient(os.Getenv("HOTEL_SERVICE_HOST"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to create hotel client")
        }</span>
        <span class="cov0" title="0">defer hotelClient.Close()

        brokers := strings.Split(os.Getenv("KAFKA_BROKERS"), ",")
        producer := kafka.NewProducer(brokers, os.Getenv("KAFKA_TOPIC_BOOKING_CREATED"))
        defer producer.Close()

        var paymentClient usecase.PaymentClient
        paymentServiceURL := os.Getenv("PAYMENT_SERVICE_URL")
        if paymentServiceURL != "" </span><span class="cov0" title="0">{
                paymentHTTPClient := httpclient.NewPaymentClient(paymentServiceURL)
                var paymentClientInterface usecase.PaymentClientInterface = paymentHTTPClient
                paymentClient = usecase.NewPaymentClientAdapter(paymentClientInterface)
        }</span>

        <span class="cov0" title="0">bookingUseCase := usecase.NewBookingUseCase(bookingRepo, hotelClient, producer, paymentClient)

        httpPort := os.Getenv("BOOKING_SERVICE_PORT")

        go func() </span><span class="cov0" title="0">{
                handler := httpHandler.NewBookingHandler(bookingUseCase)
                router := httpHandler.SetupRoutes(handler)

                log.Infof("starting HTTP server on port %s", httpPort)
                if err := http.ListenAndServe(":"+httpPort, router); err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Fatal("failed to start HTTP server")
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                prometheusPort := os.Getenv("PROMETHEUS_PORT")
                http.Handle("/metrics", promhttp.Handler())
                log.Infof("starting prometheus metrics on port %s", prometheusPort)
                http.ListenAndServe(":"+prometheusPort, nil)
        }</span>()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down booking service")
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _ = ctx</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        httpHandler "hotel-booking-system/internal/delivery/http"
        "hotel-booking-system/internal/delivery/service"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/tracing"

        "github.com/joho/godotenv"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()

        logger.Init(os.Getenv("LOG_LEVEL"))
        log := logger.GetLogger()

        tp, err := tracing.InitTracer("delivery-service", os.Getenv("JAEGER_ENDPOINT"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to init tracer")
        }</span>
        <span class="cov0" title="0">defer tracing.Shutdown(context.Background(), tp)

        deliveryService, err := service.NewDeliveryService(os.Getenv("TELEGRAM_BOT_TOKEN"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to create delivery service")
        }</span>

        <span class="cov0" title="0">handler := httpHandler.NewDeliveryHandler(deliveryService)
        router := httpHandler.SetupRoutes(handler)

        httpPort := os.Getenv("DELIVERY_SERVICE_PORT")
        if httpPort == "" </span><span class="cov0" title="0">{
                httpPort = "8084"
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                prometheusPort := os.Getenv("PROMETHEUS_PORT")
                http.Handle("/metrics", promhttp.Handler())
                log.Infof("starting prometheus metrics on port %s", prometheusPort)
                http.ListenAndServe(":"+prometheusPort, nil)
        }</span>()

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    ":" + httpPort,
                Handler: router,
        }

        go func() </span><span class="cov0" title="0">{
                log.Infof("starting HTTP server on port %s", httpPort)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.WithError(err).Fatal("failed to start HTTP server")
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down delivery service")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Error("failed to shutdown server gracefully")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        httpHandler "hotel-booking-system/internal/hotel/delivery/http"
        "hotel-booking-system/internal/hotel/repository"
        "hotel-booking-system/internal/hotel/usecase"
        "hotel-booking-system/pkg/database"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/tracing"

        "github.com/joho/godotenv"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()

        logger.Init(os.Getenv("LOG_LEVEL"))
        log := logger.GetLogger()

        tp, err := tracing.InitTracer("hotel-service", os.Getenv("JAEGER_ENDPOINT"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to init tracer")
        }</span>
        <span class="cov0" title="0">defer tracing.Shutdown(context.Background(), tp)

        dbCfg := database.Config{
                Host:     os.Getenv("HOTEL_DB_HOST"),
                Port:     os.Getenv("HOTEL_DB_PORT"),
                User:     os.Getenv("HOTEL_DB_USER"),
                Password: os.Getenv("HOTEL_DB_PASSWORD"),
                DBName:   os.Getenv("HOTEL_DB_NAME"),
        }

        db, err := database.NewPostgresConnection(dbCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to connect to database")
        }</span>
        <span class="cov0" title="0">defer db.Close()

        hotelRepo := repository.NewPostgresHotelRepository(db)
        roomRepo := repository.NewPostgresRoomRepository(db)
        hotelUseCase := usecase.NewHotelUseCase(hotelRepo, roomRepo)

        httpPort := os.Getenv("HOTEL_SERVICE_PORT")

        go func() </span><span class="cov0" title="0">{
                handler := httpHandler.NewHotelHandler(hotelUseCase)
                router := httpHandler.SetupRoutes(handler)

                log.Infof("starting HTTP server on port %s", httpPort)
                if err := http.ListenAndServe(":"+httpPort, router); err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Fatal("failed to start HTTP server")
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                prometheusPort := os.Getenv("PROMETHEUS_PORT")
                http.Handle("/metrics", promhttp.Handler())
                log.Infof("starting prometheus metrics on port %s", prometheusPort)
                http.ListenAndServe(":"+prometheusPort, nil)
        }</span>()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down hotel service")
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _ = ctx</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "hotel-booking-system/internal/booking/domain"
        "hotel-booking-system/internal/notification/service"
        "hotel-booking-system/pkg/httpclient"
        "hotel-booking-system/pkg/kafka"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/tracing"

        "github.com/joho/godotenv"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()

        logger.Init(os.Getenv("LOG_LEVEL"))
        log := logger.GetLogger()

        tp, err := tracing.InitTracer("notification-service", os.Getenv("JAEGER_ENDPOINT"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to init tracer")
        }</span>
        <span class="cov0" title="0">defer tracing.Shutdown(context.Background(), tp)

        deliveryServiceURL := os.Getenv("DELIVERY_SERVICE_URL")
        if deliveryServiceURL == "" </span><span class="cov0" title="0">{
                deliveryServiceURL = "http://delivery-service:8084"
        }</span>

        <span class="cov0" title="0">hotelServiceURL := os.Getenv("HOTEL_SERVICE_URL")
        if hotelServiceURL == "" </span><span class="cov0" title="0">{
                hotelServiceURL = "http://hotel-service:8081"
        }</span>

        <span class="cov0" title="0">deliveryClient := httpclient.NewDeliveryClient(deliveryServiceURL)
        hotelClient := httpclient.NewHotelHTTPClient(hotelServiceURL)

        var deliveryClientInterface service.DeliveryClient = deliveryClient
        var hotelClientInterface service.HotelClient = hotelClient

        notificationService := service.NewNotificationService(deliveryClientInterface, hotelClientInterface)

        brokers := strings.Split(os.Getenv("KAFKA_BROKERS"), ",")
        consumer := kafka.NewConsumer(
                brokers,
                os.Getenv("KAFKA_TOPIC_BOOKING_CREATED"),
                os.Getenv("KAFKA_GROUP_ID"),
        )
        defer consumer.Close()

        go func() </span><span class="cov0" title="0">{
                prometheusPort := os.Getenv("PROMETHEUS_PORT")
                http.Handle("/metrics", promhttp.Handler())
                log.Infof("starting prometheus metrics on port %s", prometheusPort)
                http.ListenAndServe(":"+prometheusPort, nil)
        }</span>()

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                log.Info("starting kafka consumer")
                consumer.ReadMessage(ctx, func(data []byte) error </span><span class="cov0" title="0">{
                        var event domain.BookingEvent
                        if err := kafka.UnmarshalMessage(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Error("failed to unmarshal booking event")
                                return err
                        }</span>

                        <span class="cov0" title="0">log.WithField("booking_id", event.BookingID).Info("received booking event")

                        if err := notificationService.ProcessBookingEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                                log.WithError(err).Error("failed to process booking event")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                })
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down notification service")
        cancel()
        time.Sleep(2 * time.Second)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        httpHandler "hotel-booking-system/internal/payment/delivery/http"
        "hotel-booking-system/internal/payment/service"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/tracing"

        "github.com/joho/godotenv"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()

        logger.Init(os.Getenv("LOG_LEVEL"))
        log := logger.GetLogger()

        tp, err := tracing.InitTracer("payment-service", os.Getenv("JAEGER_ENDPOINT"))
        if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to init tracer")
        }</span>
        <span class="cov0" title="0">defer tracing.Shutdown(context.Background(), tp)

        webhookURL := os.Getenv("BOOKING_WEBHOOK_URL")
        if webhookURL == "" </span><span class="cov0" title="0">{
                webhookURL = "http://booking-service:8082/api/webhooks/payment"
        }</span>

        <span class="cov0" title="0">paymentService := service.NewPaymentService(webhookURL)
        handler := httpHandler.NewPaymentHandler(paymentService)
        router := httpHandler.SetupRoutes(handler)

        httpPort := os.Getenv("PAYMENT_SERVICE_PORT")
        if httpPort == "" </span><span class="cov0" title="0">{
                httpPort = "8084"
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                prometheusPort := os.Getenv("PROMETHEUS_PORT")
                http.Handle("/metrics", promhttp.Handler())
                log.Infof("starting prometheus metrics on port %s", prometheusPort)
                http.ListenAndServe(":"+prometheusPort, nil)
        }</span>()

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    ":" + httpPort,
                Handler: router,
        }

        go func() </span><span class="cov0" title="0">{
                log.Infof("starting HTTP server on port %s", httpPort)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.WithError(err).Fatal("failed to start HTTP server")
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down payment service")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Error("failed to shutdown server gracefully")
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "os"
        "time"

        "hotel-booking-system/internal/hotel/domain"
        "hotel-booking-system/internal/hotel/repository"
        "hotel-booking-system/pkg/database"
        "hotel-booking-system/pkg/logger"

        "github.com/google/uuid"
        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        godotenv.Load()
        logger.Init("info")
        log := logger.GetLogger()

        log.Info("waiting for database to be ready...")
        time.Sleep(5 * time.Second)

        dbCfg := database.Config{
                Host:     os.Getenv("HOTEL_DB_HOST"),
                Port:     os.Getenv("HOTEL_DB_PORT"),
                User:     os.Getenv("HOTEL_DB_USER"),
                Password: os.Getenv("HOTEL_DB_PASSWORD"),
                DBName:   os.Getenv("HOTEL_DB_NAME"),
        }

        log.Infof("connecting to database: %s:%s", dbCfg.Host, dbCfg.Port)

        var db *sql.DB
        var err error

        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                db, err = database.NewPostgresConnection(dbCfg)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">log.WithError(err).Warnf("failed to connect to database, retry %d/10", i+1)
                time.Sleep(2 * time.Second)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Fatal("failed to connect to database after retries")
        }</span>
        <span class="cov0" title="0">defer db.Close()

        hotelRepo := repository.NewPostgresHotelRepository(db)
        roomRepo := repository.NewPostgresRoomRepository(db)

        ctx := context.Background()

        hotels := []domain.Hotel{
                {ID: uuid.New().String(), Name: "Гранд Отель Москва", Description: "Роскошный отель в центре Москвы", Address: "Москва, Тверская улица, 1", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Отель Санкт-Петербург", Description: "Комфортабельный отель у Невского проспекта", Address: "Санкт-Петербург, Невский проспект, 50", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Казань Плаза", Description: "Современный отель в историческом центре", Address: "Казань, улица Баумана, 25", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Сочи Парк Отель", Description: "Отель у моря с видом на горы", Address: "Сочи, Курортный проспект, 75", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Екатеринбург Центр", Description: "Бизнес-отель в центре города", Address: "Екатеринбург, проспект Ленина, 40", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Новосибирск Сити", Description: "Современный отель для деловых путешественников", Address: "Новосибирск, Красный проспект, 15", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Владивосток Океан", Description: "Отель с видом на бухту", Address: "Владивосток, Океанский проспект, 10", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Нижний Новгород Волга", Description: "Отель на берегу Волги", Address: "Нижний Новгород, Верхне-Волжская набережная, 3", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Калининград Европа", Description: "Уютный отель в европейском стиле", Address: "Калининград, проспект Мира, 20", OwnerID: uuid.New().String()},
                {ID: uuid.New().String(), Name: "Красноярск Сибирь", Description: "Комфортный отель в сибирском городе", Address: "Красноярск, проспект Мира, 35", OwnerID: uuid.New().String()},
        }

        roomTypes := []string{"Стандарт", "Улучшенный", "Люкс", "Делюкс", "Президентский люкс"}
        basePrices := []float64{3000, 5000, 8000, 12000, 25000}

        for _, hotel := range hotels </span><span class="cov0" title="0">{
                if err := hotelRepo.CreateHotel(ctx, &amp;hotel); err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Errorf("failed to create hotel %s", hotel.Name)
                        continue</span>
                }
                <span class="cov0" title="0">log.Infof("created hotel: %s", hotel.Name)

                for i := 1; i &lt;= 5; i++ </span><span class="cov0" title="0">{
                        for j, roomType := range roomTypes </span><span class="cov0" title="0">{
                                room := domain.Room{
                                        ID:            uuid.New().String(),
                                        HotelID:       hotel.ID,
                                        RoomNumber:    fmt.Sprintf("%d%02d", i, j+1),
                                        RoomType:      roomType,
                                        PricePerNight: basePrices[j],
                                        Capacity:      (j/2 + 1) * 2,
                                        Description:   fmt.Sprintf("Номер типа %s на %d этаже", roomType, i),
                                        IsAvailable:   true,
                                }

                                if err := roomRepo.CreateRoom(ctx, &amp;room); err != nil </span><span class="cov0" title="0">{
                                        log.WithError(err).Errorf("failed to create room %s", room.RoomNumber)
                                        continue</span>
                                }
                        }
                }
                <span class="cov0" title="0">log.Infof("created 25 rooms for hotel: %s", hotel.Name)</span>
        }

        <span class="cov0" title="0">log.Info("seed completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "encoding/json"
        "net/http"
        "time"

        "hotel-booking-system/internal/booking/domain"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"

        "github.com/go-chi/chi/v5"
)

type BookingHandler struct {
        useCase domain.BookingUseCase
}

func NewBookingHandler(useCase domain.BookingUseCase) *BookingHandler <span class="cov10" title="5">{
        return &amp;BookingHandler{useCase: useCase}
}</span>

func (h *BookingHandler) CreateBooking(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/bookings").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov1" title="1">var booking domain.Booking
        if err := json.NewDecoder(r.Body).Decode(&amp;booking); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if err := h.useCase.CreateBooking(r.Context(), &amp;booking); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to create booking")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings", "201").Inc()
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(booking)</span>
}

func (h *BookingHandler) GetBooking(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/bookings/{id}").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov1" title="1">id := chi.URLParam(r, "id")
        booking, err := h.useCase.GetBooking(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to get booking")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/{id}", "404").Inc()
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/{id}", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(booking)</span>
}

func (h *BookingHandler) GetBookingsByUser(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/bookings/user/{userId}").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov1" title="1">userID := chi.URLParam(r, "userId")
        bookings, err := h.useCase.GetBookingsByUser(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to get bookings by user")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/user/{userId}", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/user/{userId}", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(bookings)</span>
}

func (h *BookingHandler) GetBookingsByHotel(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/bookings/hotel/{hotelId}").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov1" title="1">hotelID := chi.URLParam(r, "hotelId")
        bookings, err := h.useCase.GetBookingsByHotel(r.Context(), hotelID)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to get bookings by hotel")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/hotel/{hotelId}", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/bookings/hotel/{hotelId}", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(bookings)</span>
}

type PaymentWebhookRequest struct {
        PaymentID string  `json:"payment_id"`
        BookingID string  `json:"booking_id"`
        Status    string  `json:"status"`
        Amount    float64 `json:"amount,omitempty"`
}

func (h *BookingHandler) PaymentWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/webhooks/payment").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov0" title="0">var req PaymentWebhookRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to decode webhook request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/webhooks/payment", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.useCase.UpdatePaymentStatus(r.Context(), req.BookingID, req.Status); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to update payment status")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/webhooks/payment", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/webhooks/payment", "200").Inc()
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func SetupRoutes(handler *BookingHandler) *chi.Mux <span class="cov8" title="1">{
        r := chi.NewRouter()

        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)

        r.Route("/api", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Route("/bookings", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", handler.CreateBooking)
                        r.Get("/{id}", handler.GetBooking)
                        r.Get("/user/{userId}", handler.GetBookingsByUser)
                        r.Get("/hotel/{hotelId}", handler.GetBookingsByHotel)
                }</span>)

                <span class="cov8" title="1">r.Route("/webhooks", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/payment", handler.PaymentWebhook)
                }</span>)
        })

        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "context"
        "database/sql"

        "hotel-booking-system/internal/booking/domain"
)

type PostgresBookingRepository struct {
        db *sql.DB
}

func NewPostgresBookingRepository(db *sql.DB) *PostgresBookingRepository <span class="cov10" title="19">{
        return &amp;PostgresBookingRepository{db: db}
}</span>

func (r *PostgresBookingRepository) CreateBooking(ctx context.Context, booking *domain.Booking) error <span class="cov3" title="2">{
        query := `INSERT INTO bookings (id, user_id, hotel_id, room_id, check_in_date, check_out_date, 
                          total_price, status, payment_status) 
                          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) 
                          RETURNING created_at, updated_at`
        return r.db.QueryRowContext(ctx, query,
                booking.ID, booking.UserID, booking.HotelID, booking.RoomID,
                booking.CheckInDate, booking.CheckOutDate, booking.TotalPrice,
                booking.Status, booking.PaymentStatus,
        ).Scan(&amp;booking.CreatedAt, &amp;booking.UpdatedAt)
}</span>

func (r *PostgresBookingRepository) GetBookingByID(ctx context.Context, id string) (*domain.Booking, error) <span class="cov4" title="3">{
        booking := &amp;domain.Booking{}
        query := `SELECT id, user_id, hotel_id, room_id, check_in_date, check_out_date, 
                          total_price, status, payment_status, created_at, updated_at 
                          FROM bookings WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;booking.ID, &amp;booking.UserID, &amp;booking.HotelID, &amp;booking.RoomID,
                &amp;booking.CheckInDate, &amp;booking.CheckOutDate, &amp;booking.TotalPrice,
                &amp;booking.Status, &amp;booking.PaymentStatus, &amp;booking.CreatedAt, &amp;booking.UpdatedAt,
        )
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return booking, nil</span>
}

func (r *PostgresBookingRepository) GetBookingsByUser(ctx context.Context, userID string) ([]domain.Booking, error) <span class="cov5" title="4">{
        query := `SELECT id, user_id, hotel_id, room_id, check_in_date, check_out_date, 
                          total_price, status, payment_status, created_at, updated_at 
                          FROM bookings WHERE user_id = $1 ORDER BY created_at DESC`
        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        var bookings []domain.Booking
        for rows.Next() </span><span class="cov4" title="3">{
                var booking domain.Booking
                if err := rows.Scan(
                        &amp;booking.ID, &amp;booking.UserID, &amp;booking.HotelID, &amp;booking.RoomID,
                        &amp;booking.CheckInDate, &amp;booking.CheckOutDate, &amp;booking.TotalPrice,
                        &amp;booking.Status, &amp;booking.PaymentStatus, &amp;booking.CreatedAt, &amp;booking.UpdatedAt,
                ); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">bookings = append(bookings, booking)</span>
        }
        <span class="cov3" title="2">return bookings, rows.Err()</span>
}

func (r *PostgresBookingRepository) GetBookingsByHotel(ctx context.Context, hotelID string) ([]domain.Booking, error) <span class="cov4" title="3">{
        query := `SELECT id, user_id, hotel_id, room_id, check_in_date, check_out_date, 
                          total_price, status, payment_status, created_at, updated_at 
                          FROM bookings WHERE hotel_id = $1 ORDER BY created_at DESC`
        rows, err := r.db.QueryContext(ctx, query, hotelID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var bookings []domain.Booking
        for rows.Next() </span><span class="cov1" title="1">{
                var booking domain.Booking
                if err := rows.Scan(
                        &amp;booking.ID, &amp;booking.UserID, &amp;booking.HotelID, &amp;booking.RoomID,
                        &amp;booking.CheckInDate, &amp;booking.CheckOutDate, &amp;booking.TotalPrice,
                        &amp;booking.Status, &amp;booking.PaymentStatus, &amp;booking.CreatedAt, &amp;booking.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">bookings = append(bookings, booking)</span>
        }
        <span class="cov3" title="2">return bookings, rows.Err()</span>
}

func (r *PostgresBookingRepository) UpdateBookingStatus(ctx context.Context, id, status string) error <span class="cov4" title="3">{
        query := `UPDATE bookings SET status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id, status)
        return err
}</span>

func (r *PostgresBookingRepository) UpdatePaymentStatus(ctx context.Context, id, paymentStatus string) error <span class="cov6" title="6">{
        query := `UPDATE bookings SET payment_status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id, paymentStatus)
        return err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package usecase

import (
        "context"
        "errors"
        "strings"
        "time"

        "hotel-booking-system/internal/booking/domain"

        "github.com/google/uuid"
)

type HotelClient interface {
        GetRoomPrice(ctx context.Context, hotelID, roomID string) (float64, error)
}

type MessageProducer interface {
        SendMessage(ctx context.Context, key string, value interface{}) error
}

type PaymentClient interface {
        CreatePayment(ctx context.Context, bookingID string, amount float64) error
}

type BookingUseCase struct {
        repo          domain.BookingRepository
        hotelClient   HotelClient
        producer      MessageProducer
        paymentClient PaymentClient
}

func NewBookingUseCase(repo domain.BookingRepository, hotelClient HotelClient, producer MessageProducer, paymentClient PaymentClient) *BookingUseCase <span class="cov0" title="0">{
        return &amp;BookingUseCase{
                repo:          repo,
                hotelClient:   hotelClient,
                producer:      producer,
                paymentClient: paymentClient,
        }
}</span>

func (uc *BookingUseCase) CreateBooking(ctx context.Context, booking *domain.Booking) error <span class="cov4" title="2">{
        if booking.CheckInDate.After(booking.CheckOutDate) </span><span class="cov1" title="1">{
                return errors.New("check-in date must be before check-out date")
        }</span>

        <span class="cov1" title="1">pricePerNight, err := uc.hotelClient.GetRoomPrice(ctx, booking.HotelID, booking.RoomID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">nights := int(booking.CheckOutDate.Sub(booking.CheckInDate).Hours() / 24)
        if nights &lt; 1 </span><span class="cov0" title="0">{
                nights = 1
        }</span>
        <span class="cov1" title="1">booking.TotalPrice = pricePerNight * float64(nights)

        booking.ID = uuid.New().String()
        booking.Status = "confirmed"
        booking.PaymentStatus = "pending"

        if err := uc.repo.CreateBooking(ctx, booking); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if uc.paymentClient != nil </span><span class="cov0" title="0">{
                if err := uc.paymentClient.CreatePayment(ctx, booking.ID, booking.TotalPrice); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">event := domain.BookingEvent{
                BookingID:    booking.ID,
                UserID:       booking.UserID,
                HotelID:      booking.HotelID,
                RoomID:       booking.RoomID,
                CheckInDate:  booking.CheckInDate,
                CheckOutDate: booking.CheckOutDate,
                TotalPrice:   booking.TotalPrice,
                EventType:    "booking.created",
                Timestamp:    time.Now(),
        }

        if err := uc.producer.SendMessage(ctx, booking.ID, event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (uc *BookingUseCase) GetBooking(ctx context.Context, id string) (*domain.Booking, error) <span class="cov4" title="2">{
        return uc.repo.GetBookingByID(ctx, id)
}</span>

func (uc *BookingUseCase) GetBookingsByUser(ctx context.Context, userID string) ([]domain.Booking, error) <span class="cov1" title="1">{
        return uc.repo.GetBookingsByUser(ctx, userID)
}</span>

func (uc *BookingUseCase) GetBookingsByHotel(ctx context.Context, hotelID string) ([]domain.Booking, error) <span class="cov1" title="1">{
        return uc.repo.GetBookingsByHotel(ctx, hotelID)
}</span>

func (uc *BookingUseCase) UpdatePaymentStatus(ctx context.Context, id, status string) error <span class="cov4" title="2">{
        validStatuses := []string{"pending", "paid", "failed", "refunded"}
        found := false
        for _, s := range validStatuses </span><span class="cov10" title="6">{
                if strings.EqualFold(s, status) </span><span class="cov1" title="1">{
                        found = true
                        break</span>
                }
        }
        <span class="cov4" title="2">if !found </span><span class="cov1" title="1">{
                return errors.New("invalid payment status")
        }</span>
        <span class="cov1" title="1">return uc.repo.UpdatePaymentStatus(ctx, id, status)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "context"
        "hotel-booking-system/pkg/httpclient"
)

type PaymentClientInterface interface {
        CreatePayment(ctx context.Context, req *httpclient.PaymentRequest) (*httpclient.PaymentResponse, error)
}

type paymentClientAdapter struct {
        client PaymentClientInterface
}

func NewPaymentClientAdapter(client PaymentClientInterface) PaymentClient <span class="cov10" title="5">{
        return &amp;paymentClientAdapter{client: client}
}</span>

func (a *paymentClientAdapter) CreatePayment(ctx context.Context, bookingID string, amount float64) error <span class="cov8" title="4">{
        _, err := a.client.CreatePayment(ctx, &amp;httpclient.PaymentRequest{
                BookingID: bookingID,
                Amount:    amount,
                Currency:  "RUB",
        })
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package http

import (
        "encoding/json"
        "net/http"
        "time"

        "hotel-booking-system/internal/delivery/domain"
        "hotel-booking-system/internal/delivery/service"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"
)

type DeliveryHandler struct {
        notifier service.Notifier
}

func NewDeliveryHandler(notifier service.Notifier) *DeliveryHandler <span class="cov10" title="4">{
        return &amp;DeliveryHandler{
                notifier: notifier,
        }
}</span>

func (h *DeliveryHandler) SendNotification(w http.ResponseWriter, r *http.Request) <span class="cov8" title="3">{
        start := time.Now()
        defer func() </span><span class="cov8" title="3">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/notifications/send").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov8" title="3">var req domain.SendNotificationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/notifications/send", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="2">if err := h.notifier.SendNotification(&amp;req); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to send notification")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/notifications/send", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/notifications/send", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(domain.SendNotificationResponse{
                Success: true,
                Message: "notification sent successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func SetupRoutes(handler *DeliveryHandler) *chi.Mux <span class="cov0" title="0">{
        r := chi.NewRouter()

        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)

        r.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/notifications", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/send", handler.SendNotification)
                }</span>)
        })

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "fmt"
        "hotel-booking-system/internal/delivery/domain"
        "hotel-booking-system/pkg/logger"

        tele "gopkg.in/telebot.v3"
)

type Notifier interface {
        SendNotification(req *domain.SendNotificationRequest) error
}

type DeliveryService struct {
        telegramBot *tele.Bot
}

func NewDeliveryService(telegramToken string) (*DeliveryService, error) <span class="cov10" title="6">{
        var bot *tele.Bot
        var err error

        if telegramToken != "" </span><span class="cov1" title="1">{
                bot, err = tele.NewBot(tele.Settings{
                        Token: telegramToken,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create telegram bot: %w", err)
                }</span>
        }

        <span class="cov9" title="5">return &amp;DeliveryService{
                telegramBot: bot,
        }, nil</span>
}

func (ds *DeliveryService) SendNotification(req *domain.SendNotificationRequest) error <span class="cov7" title="4">{
        switch req.Channel </span>{
        case domain.ChannelEmail:<span class="cov1" title="1">
                return ds.sendEmail(req)</span>
        case domain.ChannelSMS:<span class="cov1" title="1">
                return ds.sendSMS(req)</span>
        case domain.ChannelTelegram:<span class="cov1" title="1">
                return ds.sendTelegram(req)</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported channel: %s", req.Channel)</span>
        }
}

func (ds *DeliveryService) sendEmail(req *domain.SendNotificationRequest) error <span class="cov1" title="1">{
        logger.GetLogger().WithFields(map[string]interface{}{
                "channel":   "email",
                "recipient": req.Recipient,
                "subject":   req.Subject,
        }).Info("sending email notification")

        return nil
}</span>

func (ds *DeliveryService) sendSMS(req *domain.SendNotificationRequest) error <span class="cov1" title="1">{
        logger.GetLogger().WithFields(map[string]interface{}{
                "channel":   "sms",
                "recipient": req.Recipient,
        }).Info("sending SMS notification")

        return nil
}</span>

func (ds *DeliveryService) sendTelegram(req *domain.SendNotificationRequest) error <span class="cov1" title="1">{
        if ds.telegramBot == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("telegram bot not configured")
        }</span>

        <span class="cov0" title="0">chatID, err := parseTelegramChatID(req.Recipient)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid telegram chat ID: %w", err)
        }</span>

        <span class="cov0" title="0">message := req.Message
        if req.Subject != "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("*%s*\n\n%s", req.Subject, req.Message)
        }</span>

        <span class="cov0" title="0">_, err = ds.telegramBot.Send(&amp;tele.User{ID: chatID}, message, &amp;tele.SendOptions{
                ParseMode: tele.ModeMarkdown,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to send telegram notification")
                return err
        }</span>

        <span class="cov0" title="0">logger.GetLogger().WithFields(map[string]interface{}{
                "channel":   "telegram",
                "recipient": req.Recipient,
        }).Info("telegram notification sent")

        return nil</span>
}

func parseTelegramChatID(recipient string) (int64, error) <span class="cov6" title="3">{
        var chatID int64
        _, err := fmt.Sscanf(recipient, "%d", &amp;chatID)
        if err != nil </span><span class="cov4" title="2">{
                return 0, err
        }</span>
        <span class="cov1" title="1">return chatID, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package http

import (
        "encoding/json"
        "net/http"
        "strconv"
        "time"

        "hotel-booking-system/internal/hotel/domain"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"

        "github.com/go-chi/chi/v5"
)

type HotelHandler struct {
        useCase domain.HotelUseCase
}

func NewHotelHandler(useCase domain.HotelUseCase) *HotelHandler <span class="cov10" title="15">{
        return &amp;HotelHandler{useCase: useCase}
}</span>

func (h *HotelHandler) CreateHotel(w http.ResponseWriter, r *http.Request) <span class="cov4" title="3">{
        start := time.Now()
        defer func() </span><span class="cov4" title="3">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/hotels").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov4" title="3">var hotel domain.Hotel
        if err := json.NewDecoder(r.Body).Decode(&amp;hotel); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">if err := h.useCase.CreateHotel(r.Context(), &amp;hotel); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to create hotel")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels", "201").Inc()
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(hotel)</span>
}

func (h *HotelHandler) GetHotel(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        start := time.Now()
        defer func() </span><span class="cov1" title="1">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/hotels/{id}").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov1" title="1">id := chi.URLParam(r, "id")
        hotel, err := h.useCase.GetHotel(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to get hotel")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}", "404").Inc()
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(hotel)</span>
}

func (h *HotelHandler) GetHotels(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        start := time.Now()
        defer func() </span><span class="cov3" title="2">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/hotels").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov3" title="2">limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        hotels, err := h.useCase.GetHotels(r.Context(), limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to get hotels")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(hotels)</span>
}

func (h *HotelHandler) GetHotelWithRooms(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        start := time.Now()
        defer func() </span><span class="cov3" title="2">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/hotels/{id}/rooms").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov3" title="2">id := chi.URLParam(r, "id")
        hotelWithRooms, err := h.useCase.GetHotelWithRooms(r.Context(), id)
        if err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to get hotel with rooms")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}/rooms", "404").Inc()
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}/rooms", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(hotelWithRooms)</span>
}

func (h *HotelHandler) UpdateHotel(w http.ResponseWriter, r *http.Request) <span class="cov4" title="3">{
        start := time.Now()
        defer func() </span><span class="cov4" title="3">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/hotels/{id}").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov4" title="3">id := chi.URLParam(r, "id")
        var hotel domain.Hotel
        if err := json.NewDecoder(r.Body).Decode(&amp;hotel); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov3" title="2">hotel.ID = id

        if err := h.useCase.UpdateHotel(r.Context(), &amp;hotel); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to update hotel")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/hotels/{id}", "200").Inc()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(hotel)</span>
}

func (h *HotelHandler) CreateRoom(w http.ResponseWriter, r *http.Request) <span class="cov4" title="3">{
        start := time.Now()
        defer func() </span><span class="cov4" title="3">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/rooms").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov4" title="3">var room domain.Room
        if err := json.NewDecoder(r.Body).Decode(&amp;room); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/rooms", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">if err := h.useCase.CreateRoom(r.Context(), &amp;room); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to create room")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/rooms", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/rooms", "201").Inc()
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(room)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func SetupRoutes(handler *HotelHandler) *chi.Mux <span class="cov8" title="1">{
        r := chi.NewRouter()

        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)

        r.Route("/api", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Route("/hotels", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Get("/", handler.GetHotels)
                        r.Post("/", handler.CreateHotel)
                        r.Get("/{id}", handler.GetHotel)
                        r.Put("/{id}", handler.UpdateHotel)
                        r.Get("/{id}/rooms", handler.GetHotelWithRooms)
                }</span>)

                <span class="cov8" title="1">r.Route("/rooms", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", handler.CreateRoom)
                }</span>)
        })

        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "database/sql"

        "hotel-booking-system/internal/hotel/domain"
)

type PostgresHotelRepository struct {
        db *sql.DB
}

func NewPostgresHotelRepository(db *sql.DB) *PostgresHotelRepository <span class="cov10" title="20">{
        return &amp;PostgresHotelRepository{db: db}
}</span>

func (r *PostgresHotelRepository) CreateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov3" title="2">{
        query := `INSERT INTO hotels (id, name, description, address, owner_id) 
                          VALUES ($1, $2, $3, $4, $5) 
                          RETURNING created_at, updated_at`
        return r.db.QueryRowContext(ctx, query,
                hotel.ID, hotel.Name, hotel.Description, hotel.Address, hotel.OwnerID,
        ).Scan(&amp;hotel.CreatedAt, &amp;hotel.UpdatedAt)
}</span>

func (r *PostgresHotelRepository) GetHotelByID(ctx context.Context, id string) (*domain.Hotel, error) <span class="cov4" title="3">{
        hotel := &amp;domain.Hotel{}
        query := `SELECT id, name, description, address, owner_id, created_at, updated_at 
                          FROM hotels WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;hotel.ID, &amp;hotel.Name, &amp;hotel.Description, &amp;hotel.Address,
                &amp;hotel.OwnerID, &amp;hotel.CreatedAt, &amp;hotel.UpdatedAt,
        )
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return hotel, nil</span>
}

func (r *PostgresHotelRepository) GetHotels(ctx context.Context, limit, offset int) ([]domain.Hotel, error) <span class="cov5" title="5">{
        query := `SELECT id, name, description, address, owner_id, created_at, updated_at 
                          FROM hotels ORDER BY created_at DESC LIMIT $1 OFFSET $2`
        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="4">defer rows.Close()

        var hotels []domain.Hotel
        for rows.Next() </span><span class="cov5" title="4">{
                var hotel domain.Hotel
                if err := rows.Scan(
                        &amp;hotel.ID, &amp;hotel.Name, &amp;hotel.Description, &amp;hotel.Address,
                        &amp;hotel.OwnerID, &amp;hotel.CreatedAt, &amp;hotel.UpdatedAt,
                ); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov4" title="3">hotels = append(hotels, hotel)</span>
        }
        <span class="cov4" title="3">return hotels, rows.Err()</span>
}

func (r *PostgresHotelRepository) GetHotelsByOwner(ctx context.Context, ownerID string) ([]domain.Hotel, error) <span class="cov4" title="3">{
        query := `SELECT id, name, description, address, owner_id, created_at, updated_at 
                          FROM hotels WHERE owner_id = $1 ORDER BY created_at DESC`
        rows, err := r.db.QueryContext(ctx, query, ownerID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var hotels []domain.Hotel
        for rows.Next() </span><span class="cov3" title="2">{
                var hotel domain.Hotel
                if err := rows.Scan(
                        &amp;hotel.ID, &amp;hotel.Name, &amp;hotel.Description, &amp;hotel.Address,
                        &amp;hotel.OwnerID, &amp;hotel.CreatedAt, &amp;hotel.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">hotels = append(hotels, hotel)</span>
        }
        <span class="cov3" title="2">return hotels, rows.Err()</span>
}

func (r *PostgresHotelRepository) UpdateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov4" title="3">{
        query := `UPDATE hotels SET name = $2, description = $3, address = $4, 
                          updated_at = CURRENT_TIMESTAMP WHERE id = $1
                          RETURNING updated_at`
        return r.db.QueryRowContext(ctx, query,
                hotel.ID, hotel.Name, hotel.Description, hotel.Address,
        ).Scan(&amp;hotel.UpdatedAt)
}</span>

func (r *PostgresHotelRepository) DeleteHotel(ctx context.Context, id string) error <span class="cov4" title="3">{
        query := `DELETE FROM hotels WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"
        "database/sql"

        "hotel-booking-system/internal/hotel/domain"
)

type PostgresRoomRepository struct {
        db *sql.DB
}

func NewPostgresRoomRepository(db *sql.DB) *PostgresRoomRepository <span class="cov10" title="23">{
        return &amp;PostgresRoomRepository{db: db}
}</span>

func (r *PostgresRoomRepository) CreateRoom(ctx context.Context, room *domain.Room) error <span class="cov4" title="3">{
        query := `INSERT INTO rooms (id, hotel_id, room_number, room_type, price_per_night, capacity, description, is_available) 
                          VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
                          RETURNING created_at, updated_at`
        return r.db.QueryRowContext(ctx, query,
                room.ID, room.HotelID, room.RoomNumber, room.RoomType,
                room.PricePerNight, room.Capacity, room.Description, room.IsAvailable,
        ).Scan(&amp;room.CreatedAt, &amp;room.UpdatedAt)
}</span>

func (r *PostgresRoomRepository) GetRoomByID(ctx context.Context, id string) (*domain.Room, error) <span class="cov4" title="3">{
        room := &amp;domain.Room{}
        query := `SELECT id, hotel_id, room_number, room_type, price_per_night, capacity, 
                          description, is_available, created_at, updated_at 
                          FROM rooms WHERE id = $1`
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;room.ID, &amp;room.HotelID, &amp;room.RoomNumber, &amp;room.RoomType,
                &amp;room.PricePerNight, &amp;room.Capacity, &amp;room.Description,
                &amp;room.IsAvailable, &amp;room.CreatedAt, &amp;room.UpdatedAt,
        )
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return room, nil</span>
}

func (r *PostgresRoomRepository) GetRoomsByHotel(ctx context.Context, hotelID string) ([]domain.Room, error) <span class="cov6" title="6">{
        query := `SELECT id, hotel_id, room_number, room_type, price_per_night, capacity, 
                          description, is_available, created_at, updated_at 
                          FROM rooms WHERE hotel_id = $1 ORDER BY room_number`
        rows, err := r.db.QueryContext(ctx, query, hotelID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="5">defer rows.Close()

        var rooms []domain.Room
        for rows.Next() </span><span class="cov6" title="6">{
                var room domain.Room
                if err := rows.Scan(
                        &amp;room.ID, &amp;room.HotelID, &amp;room.RoomNumber, &amp;room.RoomType,
                        &amp;room.PricePerNight, &amp;room.Capacity, &amp;room.Description,
                        &amp;room.IsAvailable, &amp;room.CreatedAt, &amp;room.UpdatedAt,
                ); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov5" title="5">rooms = append(rooms, room)</span>
        }
        <span class="cov4" title="4">return rooms, rows.Err()</span>
}

func (r *PostgresRoomRepository) UpdateRoom(ctx context.Context, room *domain.Room) error <span class="cov4" title="3">{
        query := `UPDATE rooms SET room_number = $2, room_type = $3, price_per_night = $4, 
                          capacity = $5, description = $6, is_available = $7, updated_at = CURRENT_TIMESTAMP 
                          WHERE id = $1 RETURNING updated_at`
        return r.db.QueryRowContext(ctx, query,
                room.ID, room.RoomNumber, room.RoomType, room.PricePerNight,
                room.Capacity, room.Description, room.IsAvailable,
        ).Scan(&amp;room.UpdatedAt)
}</span>

func (r *PostgresRoomRepository) DeleteRoom(ctx context.Context, id string) error <span class="cov4" title="3">{
        query := `DELETE FROM rooms WHERE id = $1`
        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>

func (r *PostgresRoomRepository) GetRoomPrice(ctx context.Context, hotelID, roomID string) (float64, error) <span class="cov4" title="4">{
        var price float64
        query := `SELECT price_per_night FROM rooms WHERE id = $1 AND hotel_id = $2`
        err := r.db.QueryRowContext(ctx, query, roomID, hotelID).Scan(&amp;price)
        return price, err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package usecase

import (
        "context"
        "errors"

        "hotel-booking-system/internal/hotel/domain"

        "github.com/google/uuid"
)

type HotelUseCase struct {
        hotelRepo domain.HotelRepository
        roomRepo  domain.RoomRepository
}

func NewHotelUseCase(hotelRepo domain.HotelRepository, roomRepo domain.RoomRepository) *HotelUseCase <span class="cov10" title="15">{
        return &amp;HotelUseCase{
                hotelRepo: hotelRepo,
                roomRepo:  roomRepo,
        }
}</span>

func (uc *HotelUseCase) CreateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov3" title="2">{
        if hotel.Name == "" || hotel.Address == "" || hotel.OwnerID == "" </span><span class="cov1" title="1">{
                return errors.New("invalid hotel data")
        }</span>
        <span class="cov1" title="1">hotel.ID = uuid.New().String()
        return uc.hotelRepo.CreateHotel(ctx, hotel)</span>
}

func (uc *HotelUseCase) GetHotel(ctx context.Context, id string) (*domain.Hotel, error) <span class="cov1" title="1">{
        return uc.hotelRepo.GetHotelByID(ctx, id)
}</span>

func (uc *HotelUseCase) GetHotels(ctx context.Context, limit, offset int) ([]domain.Hotel, error) <span class="cov1" title="1">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                limit = 20
        }</span>
        <span class="cov1" title="1">return uc.hotelRepo.GetHotels(ctx, limit, offset)</span>
}

func (uc *HotelUseCase) GetHotelsByOwner(ctx context.Context, ownerID string) ([]domain.Hotel, error) <span class="cov1" title="1">{
        return uc.hotelRepo.GetHotelsByOwner(ctx, ownerID)
}</span>

func (uc *HotelUseCase) UpdateHotel(ctx context.Context, hotel *domain.Hotel) error <span class="cov3" title="2">{
        existing, err := uc.hotelRepo.GetHotelByID(ctx, hotel.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">if existing.OwnerID != hotel.OwnerID </span><span class="cov1" title="1">{
                return errors.New("unauthorized to update this hotel")
        }</span>
        <span class="cov1" title="1">return uc.hotelRepo.UpdateHotel(ctx, hotel)</span>
}

func (uc *HotelUseCase) DeleteHotel(ctx context.Context, id, ownerID string) error <span class="cov1" title="1">{
        existing, err := uc.hotelRepo.GetHotelByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if existing.OwnerID != ownerID </span><span class="cov0" title="0">{
                return errors.New("unauthorized to delete this hotel")
        }</span>
        <span class="cov1" title="1">return uc.hotelRepo.DeleteHotel(ctx, id)</span>
}

func (uc *HotelUseCase) CreateRoom(ctx context.Context, room *domain.Room) error <span class="cov1" title="1">{
        room.ID = uuid.New().String()
        return uc.roomRepo.CreateRoom(ctx, room)
}</span>

func (uc *HotelUseCase) GetRoom(ctx context.Context, id string) (*domain.Room, error) <span class="cov1" title="1">{
        return uc.roomRepo.GetRoomByID(ctx, id)
}</span>

func (uc *HotelUseCase) GetRoomsByHotel(ctx context.Context, hotelID string) ([]domain.Room, error) <span class="cov1" title="1">{
        return uc.roomRepo.GetRoomsByHotel(ctx, hotelID)
}</span>

func (uc *HotelUseCase) GetHotelWithRooms(ctx context.Context, hotelID string) (*domain.HotelWithRooms, error) <span class="cov3" title="2">{
        hotel, err := uc.hotelRepo.GetHotelByID(ctx, hotelID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rooms, err := uc.roomRepo.GetRoomsByHotel(ctx, hotelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;domain.HotelWithRooms{
                Hotel: *hotel,
                Rooms: rooms,
        }, nil</span>
}

func (uc *HotelUseCase) UpdateRoom(ctx context.Context, room *domain.Room) error <span class="cov1" title="1">{
        return uc.roomRepo.UpdateRoom(ctx, room)
}</span>

func (uc *HotelUseCase) GetRoomPrice(ctx context.Context, hotelID, roomID string) (float64, error) <span class="cov1" title="1">{
        return uc.roomRepo.GetRoomPrice(ctx, hotelID, roomID)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"
        "fmt"
        "hotel-booking-system/internal/booking/domain"
        "hotel-booking-system/pkg/httpclient"
        "hotel-booking-system/pkg/logger"
)

type DeliveryClient interface {
        SendNotification(ctx context.Context, req *httpclient.SendNotificationRequest) error
}

type HotelClient interface {
        GetHotelOwnerID(ctx context.Context, hotelID string) (string, error)
}

type NotificationService struct {
        deliveryClient DeliveryClient
        hotelClient    HotelClient
}

func NewNotificationService(deliveryClient DeliveryClient, hotelClient HotelClient) *NotificationService <span class="cov10" title="5">{
        return &amp;NotificationService{
                deliveryClient: deliveryClient,
                hotelClient:    hotelClient,
        }
}</span>

func (ns *NotificationService) ProcessBookingEvent(ctx context.Context, event domain.BookingEvent) error <span class="cov8" title="4">{
        clientMessage := FormatBookingNotificationForClient(
                event.BookingID,
                event.HotelID,
                event.TotalPrice,
                event.CheckInDate,
                event.CheckOutDate,
        )

        if err := ns.deliveryClient.SendNotification(ctx, &amp;httpclient.SendNotificationRequest{
                Channel:   "email",
                Recipient: event.UserID,
                Subject:   "Бронирование подтверждено",
                Message:   clientMessage,
        }); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to send notification to client")
        }</span>

        <span class="cov8" title="4">ownerID, err := ns.hotelClient.GetHotelOwnerID(ctx, event.HotelID)
        if err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to get hotel owner ID")
        }</span> else<span class="cov7" title="3"> {
                hotelierMessage := FormatBookingNotificationForHotelier(
                        event.BookingID,
                        event.UserID,
                        event.HotelID,
                        event.TotalPrice,
                        event.CheckInDate,
                        event.CheckOutDate,
                )

                if err := ns.deliveryClient.SendNotification(ctx, &amp;httpclient.SendNotificationRequest{
                        Channel:   "email",
                        Recipient: ownerID,
                        Subject:   "Новое бронирование в вашем отеле",
                        Message:   hotelierMessage,
                }); err != nil </span><span class="cov1" title="1">{
                        logger.GetLogger().WithError(err).Error("failed to send notification to hotelier")
                }</span>
        }

        <span class="cov8" title="4">return nil</span>
}

func FormatBookingNotificationForClient(bookingID, hotelID string, totalPrice float64, checkIn, checkOut interface{}) string <span class="cov10" title="5">{
        return fmt.Sprintf(
                "Ваше бронирование подтверждено!\n\nID бронирования: %s\nОтель: %s\nСумма: %.2f руб.\nДата заезда: %v\nДата выезда: %v\n\nСпасибо за выбор нашего сервиса!",
                bookingID, hotelID, totalPrice, checkIn, checkOut,
        )
}</span>

func FormatBookingNotificationForHotelier(bookingID, userID, hotelID string, totalPrice float64, checkIn, checkOut interface{}) string <span class="cov8" title="4">{
        return fmt.Sprintf(
                "Новое бронирование в вашем отеле!\n\nID бронирования: %s\nПользователь: %s\nОтель: %s\nСумма: %.2f руб.\nДата заезда: %v\nДата выезда: %v",
                bookingID, userID, hotelID, totalPrice, checkIn, checkOut,
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package http

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "hotel-booking-system/internal/payment/domain"
        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"
)

type PaymentService interface {
        ProcessPayment(ctx context.Context, req *domain.PaymentRequest) (*domain.PaymentResponse, error)
}

type PaymentHandler struct {
        paymentService PaymentService
}

func NewPaymentHandler(paymentService PaymentService) *PaymentHandler <span class="cov10" title="5">{
        return &amp;PaymentHandler{
                paymentService: paymentService,
        }
}</span>

func (h *PaymentHandler) CreatePayment(w http.ResponseWriter, r *http.Request) <span class="cov8" title="4">{
        start := time.Now()
        defer func() </span><span class="cov8" title="4">{
                metrics.HTTPRequestDuration.WithLabelValues(r.Method, "/api/payments").Observe(time.Since(start).Seconds())
        }</span>()

        <span class="cov8" title="4">var req domain.PaymentRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to decode request")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/payments", "400").Inc()
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov7" title="3">if req.Currency == "" </span><span class="cov4" title="2">{
                req.Currency = "RUB"
        }</span>

        <span class="cov7" title="3">response, err := h.paymentService.ProcessPayment(r.Context(), &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to process payment")
                metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/payments", "500").Inc()
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov4" title="2">metrics.HTTPRequestsTotal.WithLabelValues(r.Method, "/api/payments", "202").Inc()
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusAccepted)
        json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package http

import (
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func SetupRoutes(handler *PaymentHandler) *chi.Mux <span class="cov0" title="0">{
        r := chi.NewRouter()

        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)

        r.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Route("/payments", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Post("/", handler.CreatePayment)
                }</span>)
        })

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "hotel-booking-system/internal/payment/domain"
        "hotel-booking-system/pkg/logger"

        "github.com/google/uuid"
)

type PaymentService struct {
        webhookURL string
}

func NewPaymentService(webhookURL string) *PaymentService <span class="cov10" title="7">{
        return &amp;PaymentService{
                webhookURL: webhookURL,
        }
}</span>

func (ps *PaymentService) ProcessPayment(ctx context.Context, req *domain.PaymentRequest) (*domain.PaymentResponse, error) <span class="cov6" title="3">{
        paymentID := uuid.New().String()

        response := &amp;domain.PaymentResponse{
                PaymentID: paymentID,
                Status:    "processing",
                Message:   "payment is being processed",
        }

        go ps.processPaymentAsync(ctx, paymentID, req)

        return response, nil
}</span>

func (ps *PaymentService) processPaymentAsync(ctx context.Context, paymentID string, req *domain.PaymentRequest) <span class="cov6" title="3">{
        time.Sleep(2 * time.Second)

        status := "paid"
        if req.Amount &lt;= 0 </span><span class="cov4" title="2">{
                status = "failed"
        }</span>

        <span class="cov6" title="3">webhook := domain.PaymentWebhook{
                PaymentID:   paymentID,
                BookingID:   req.BookingID,
                Status:      status,
                Amount:      req.Amount,
                ProcessedAt: time.Now().Format(time.RFC3339),
        }

        if err := ps.sendWebhook(ctx, webhook); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to send payment webhook")
        }</span>
}

func (ps *PaymentService) sendWebhook(ctx context.Context, webhook domain.PaymentWebhook) error <span class="cov9" title="6">{
        data, err := json.Marshal(webhook)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal webhook: %w", err)
        }</span>

        <span class="cov9" title="6">req, err := http.NewRequestWithContext(ctx, "POST", ps.webhookURL, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook request: %w", err)
        }</span>

        <span class="cov9" title="6">req.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to send webhook: %w", err)
        }</span>
        <span class="cov8" title="5">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return fmt.Errorf("webhook returned status %d", resp.StatusCode)
        }</span>

        <span class="cov7" title="4">logger.GetLogger().WithFields(map[string]interface{}{
                "payment_id": webhook.PaymentID,
                "booking_id": webhook.BookingID,
                "status":     webhook.Status,
        }).Info("payment webhook sent successfully")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package database

import (
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"
)

type Config struct {
        Host     string
        Port     string
        User     string
        Password string
        DBName   string
}

func NewPostgresConnection(cfg Config) (*sql.DB, error) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package hotelclient

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

type HotelClient struct {
        baseURL string
}

func NewHotelClient(addr string) (*HotelClient, error) <span class="cov10" title="3">{
        return &amp;HotelClient{
                baseURL: fmt.Sprintf("http://%s", addr),
        }, nil
}</span>

func (c *HotelClient) GetRoomPrice(ctx context.Context, hotelID, roomID string) (float64, error) <span class="cov1" title="1">{
        url := fmt.Sprintf("%s/api/hotels/%s/rooms", c.baseURL, hotelID)
        
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        
        <span class="cov1" title="1">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("hotel service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result struct {
                Hotel struct{} `json:"hotel"`
                Rooms []struct {
                        ID            string  `json:"id"`
                        PricePerNight float64 `json:"price_per_night"`
                } `json:"rooms"`
        }

        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse hotel service response: %w", err)
        }</span>

        <span class="cov0" title="0">for _, room := range result.Rooms </span><span class="cov0" title="0">{
                if room.ID == roomID </span><span class="cov0" title="0">{
                        return room.PricePerNight, nil
                }</span>
        }

        <span class="cov0" title="0">return 0, fmt.Errorf("room %s not found in hotel %s", roomID, hotelID)</span>
}

func (c *HotelClient) Close() error <span class="cov10" title="3">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package httpclient

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "hotel-booking-system/pkg/logger"
)

type DeliveryClient struct {
        baseURL string
        client  *http.Client
}

func NewDeliveryClient(baseURL string) *DeliveryClient <span class="cov10" title="5">{
        return &amp;DeliveryClient{
                baseURL: baseURL,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

type SendNotificationRequest struct {
        Channel   string `json:"channel"`
        Recipient string `json:"recipient"`
        Subject   string `json:"subject,omitempty"`
        Message   string `json:"message"`
}

func (c *DeliveryClient) SendNotification(ctx context.Context, req *SendNotificationRequest) error <span class="cov8" title="4">{
        url := fmt.Sprintf("%s/api/notifications/send", c.baseURL)

        data, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="4">httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="4">httpReq.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(httpReq)
        if err != nil </span><span class="cov4" title="2">{
                logger.GetLogger().WithError(err).Error("failed to send notification via delivery service")
                return err
        }</span>
        <span class="cov4" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                return fmt.Errorf("delivery service returned status %d", resp.StatusCode)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package httpclient

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

type HotelHTTPClient struct {
        baseURL string
        client  *http.Client
}

func NewHotelHTTPClient(baseURL string) *HotelHTTPClient <span class="cov10" title="6">{
        return &amp;HotelHTTPClient{
                baseURL: baseURL,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

type Hotel struct {
        ID      string `json:"id"`
        OwnerID string `json:"owner_id"`
}

func (c *HotelHTTPClient) GetHotelOwnerID(ctx context.Context, hotelID string) (string, error) <span class="cov9" title="5">{
        url := fmt.Sprintf("%s/api/hotels/%s", c.baseURL, hotelID)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov9" title="5">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to get hotel: %w", err)
        }</span>
        <span class="cov7" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov4" title="2">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("hotel service returned status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="2">var hotel Hotel
        if err := json.NewDecoder(resp.Body).Decode(&amp;hotel); err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to decode hotel: %w", err)
        }</span>

        <span class="cov1" title="1">return hotel.OwnerID, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package httpclient

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "hotel-booking-system/pkg/logger"
)

type PaymentClient struct {
        baseURL string
        client  *http.Client
}

func NewPaymentClient(baseURL string) *PaymentClient <span class="cov10" title="6">{
        return &amp;PaymentClient{
                baseURL: baseURL,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

type PaymentRequest struct {
        BookingID string  `json:"booking_id"`
        Amount    float64 `json:"amount"`
        Currency  string  `json:"currency,omitempty"`
}

type PaymentResponse struct {
        PaymentID string `json:"payment_id"`
        Status    string `json:"status"`
        Message   string `json:"message,omitempty"`
}

func (c *PaymentClient) CreatePayment(ctx context.Context, req *PaymentRequest) (*PaymentResponse, error) <span class="cov9" title="5">{
        url := fmt.Sprintf("%s/api/payments", c.baseURL)

        data, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov9" title="5">httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov9" title="5">httpReq.Header.Set("Content-Type", "application/json")

        resp, err := c.client.Do(httpReq)
        if err != nil </span><span class="cov1" title="1">{
                logger.GetLogger().WithError(err).Error("failed to create payment")
                return nil, err
        }</span>
        <span class="cov7" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusAccepted </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("payment service returned status %d", resp.StatusCode)
        }</span>

        <span class="cov4" title="2">var paymentResp PaymentResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;paymentResp); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;paymentResp, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package kafka

import (
        "context"
        "encoding/json"

        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"

        "github.com/segmentio/kafka-go"
)

type Consumer struct {
        reader *kafka.Reader
}

func NewConsumer(brokers []string, topic, groupID string) *Consumer <span class="cov1" title="1">{
        return &amp;Consumer{
                reader: kafka.NewReader(kafka.ReaderConfig{
                        Brokers:  brokers,
                        Topic:    topic,
                        GroupID:  groupID,
                        MinBytes: 10e3,
                        MaxBytes: 10e6,
                }),
        }
}</span>

func (c *Consumer) ReadMessage(ctx context.Context, handler func([]byte) error) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                msg, err := c.reader.ReadMessage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.GetLogger().WithError(err).Error("failed to read kafka message")
                        return err
                }</span>

                <span class="cov0" title="0">metrics.KafkaMessagesConsumed.Inc()
                logger.GetLogger().WithField("offset", msg.Offset).Info("kafka message received")

                if err := handler(msg.Value); err != nil </span><span class="cov0" title="0">{
                        logger.GetLogger().WithError(err).Error("failed to handle kafka message")
                }</span>
        }
}

func (c *Consumer) Close() error <span class="cov0" title="0">{
        return c.reader.Close()
}</span>

func UnmarshalMessage(data []byte, v interface{}) error <span class="cov10" title="2">{
        return json.Unmarshal(data, v)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package kafka

import (
        "context"
        "encoding/json"

        "hotel-booking-system/pkg/logger"
        "hotel-booking-system/pkg/metrics"

        "github.com/segmentio/kafka-go"
)

type Producer struct {
        writer *kafka.Writer
}

func NewProducer(brokers []string, topic string) *Producer <span class="cov10" title="2">{
        return &amp;Producer{
                writer: &amp;kafka.Writer{
                        Addr:     kafka.TCP(brokers...),
                        Topic:    topic,
                        Balancer: &amp;kafka.LeastBytes{},
                },
        }
}</span>

func (p *Producer) SendMessage(ctx context.Context, key string, value interface{}) error <span class="cov1" title="1">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">msg := kafka.Message{
                Key:   []byte(key),
                Value: data,
        }

        if err := p.writer.WriteMessages(ctx, msg); err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().WithError(err).Error("failed to send kafka message")
                return err
        }</span>

        <span class="cov0" title="0">metrics.KafkaMessagesProduced.Inc()
        logger.GetLogger().WithField("key", key).Info("kafka message sent")
        return nil</span>
}

func (p *Producer) Close() error <span class="cov0" title="0">{
        return p.writer.Close()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

var Log *logrus.Logger

func Init(level string) <span class="cov10" title="3">{
        Log = logrus.New()
        Log.SetFormatter(&amp;logrus.JSONFormatter{})
        Log.SetOutput(os.Stdout)

        logLevel, err := logrus.ParseLevel(level)
        if err != nil </span><span class="cov1" title="1">{
                logLevel = logrus.InfoLevel
        }</span>
        <span class="cov10" title="3">Log.SetLevel(logLevel)</span>
}

func GetLogger() *logrus.Logger <span class="cov6" title="2">{
        if Log == nil </span><span class="cov1" title="1">{
                Init("info")
        }</span>
        <span class="cov6" title="2">return Log</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package tracing

import (
        "context"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/jaeger"
        "go.opentelemetry.io/otel/sdk/resource"
        tracesdk "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

func InitTracer(serviceName, jaegerEndpoint string) (*tracesdk.TracerProvider, error) <span class="cov1" title="1">{
        exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(jaegerEndpoint)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">tp := tracesdk.NewTracerProvider(
                tracesdk.WithBatcher(exp),
                tracesdk.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(serviceName),
                )),
        )

        otel.SetTracerProvider(tp)
        return tp, nil</span>
}

func Shutdown(ctx context.Context, tp *tracesdk.TracerProvider) error <span class="cov10" title="2">{
        if tp != nil </span><span class="cov1" title="1">{
                return tp.Shutdown(ctx)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
